#ifndef BRICKGAME_V2_0_BRICK_GAME_TETRIS_TETRIS_H
#define BRICKGAME_V2_0_BRICK_GAME_TETRIS_TETRIS_H

#ifdef __cplusplus
extern "C" {
#endif
#include <stdbool.h>
#include <sys/time.h>
#ifdef __linux__
#include <time.h>
#endif

#include "../../lib_struct.h"
/**
 * @brief Количество строк и столбцов в матрицы отвечающий за игровое поле.
 *
 * @note Значения:
 * - ROWS: Количество строк.
 * - COLUMNS: Количество столбцов.
 */
#define ROWS 20
#define COLUMNS 10
/**
 * @brief Количество строк и столбцов в матрице хранящей следующую фигуру.
 */
#define NEXT_ROWS_AND_COLUMNS 4

/**
 * @struct FigureInfo
 * @brief Структура для хранения информации об текущей и следующей фигуры.
 *
 * Хранит различные параметры фигуры, такие как вид, в каком положении,
 * двигается или нет, координаты для поиска на поле.
 */
typedef struct {
  int coor_x;
  int coor_y;
  int type_figure;
  int type_position;
  int next_type_figure;
  int next_type_position;
  bool moving;
} FigureInfo;

/**
 * @enum FigureInfo
 * @brief Состояние игровой логики.
 *
 * Позволяет определить, на каком этапе сейчас находится игра.
 */
typedef enum {
  kStartGame, /**< Начало игры. */
  kSpawn,     /**< Появление фигуры. */
  kShift,     /**< Падение фигуры по таймеру. */
  kAttaching, /**< Проверка когда блок упал полностью, будет ли проходить */
              /**< уничтожение линий или нет. */
  kGameOver   /**< Конец игры. */
} FieldState;

/**
 * @enum Tetromino
 * @brief Перечисление всех фигур Тетриса.
 */
typedef enum {
  kFIGURE1,  // Длинная палка
  kFIGURE2,  // Г-фигура
  kFIGURE3,  // L-фигура
  kFIGURE4,  // Квадрат
  kFIGURE5,  // Змея с головой поднятой справа
  kFIGURE6,  // Т-образная фигура
  kFIGURE7   // Змея с головой поднятой слева
} Tetromino;

/**
 * @brief Обрабатывает ввод.
 * @param action Тип нажатой клавиши.
 * @param hold Зажатие клавиши.
 */
void userInput(UserAction_t action, bool hold);

/**
 * @return Возвращает копию структуры для отрисовк.
 */
GameInfo_t updateCurrentState();

/**
 * @brief Получает информацию о текущей игре.
 * @param switch_flag Флаг переключения. Если true, игра будет сброшена и
 * освободится память, иначе информация о текущей игре будет обновлена и
 * возвращена.
 *
 * Эта функция инициализирует структуру GameInfo_t, обрабатывает состояние игры
 * и возвращает указатель на нее. Если функция вызывается с флагом переключения,
 * происходит сброс игровой информации и освобождается память, занимаемая полями
 * игры.
 *
 * @return Указатель на `GameInfo_t`, содержащий текущую информацию об игре.
 *
 * @note Функция использует статические переменные для хранения состояния игры,
 *       поэтому последующие вызовы будут запоминать предыдущие состояния.
 */
GameInfo_t *GetGameInfo_t(bool switch_flag);

/**
 * @brief Инициализирует игровое поле и поле для следующей фигуры.
 * @param game_info Указатель на структуру GameInfo_t, содержащую информацию об
 * игре.
 * @param switch_flag Флаг, указывающий, нужно ли переключить состояние. Если
 * это значение true и при чтении высокого счета происходит ошибка, то будет
 * установлено значение true для switch_flag.
 * @param start_time Указатель на структуру struct timeval, которая будет
 * заполнена текущим временем.
 *
 * Эта функция выделяет память для текущего игрового поля и следующей фигуры.
 * При успешном выделении памяти функция устанавливает начальное значение
 * высокого счета и получает текущее время.
 *
 * @return true, если игровое поле было успешно инициализировано, иначе false.
 *
 * @note Функция использует динамическое выделение памяти, для освобождения
 * памяти необходимо использовать соответствующую функцию (например, блок
 * освобождения памяти в вызывающей функции).
 */
bool InitialGameField(GameInfo_t *game_info, bool *switch_flag,
                      struct timeval *start_time);

/**
 * @brief Освобождает память при не успешном выделении.
 * @param field Поле для которого не выделилась полностью память.
 * @param int Индекс на котором память не смогла выделиться.
 */
void FailFree(int **field, int i);

/**
 * @brief Считывание сохраненного результата из текстового файла.
 * @return Возвращает сохраненный результат.
 */
int ReadScore();

/**
 * @brief Сохранение результата в текстовый файл.
 * @param new_score Новый рекорд который будет сохранен.
 */
void SaveScore(int new_score);

/**
 * @param start_time Время с которого идет отсчет.
 * @param current_time Прошедшее время.
 * @return Возвращает разницу между прошедшим временем и временем отсчета.
 */
double GetTimeDifference(struct timeval start_time,
                         struct timeval current_time);

/**
 * @brief Проверяет врежется ли фигура при перемещение.
 * @param action Направление по которому проверяется может ли фигура сдвинуться
 * @param game_info Информация об игре содержащую поле на котором ищется фигура
 * и смотрится дальше по направлению есть ли дальше другая фигура или край поля.
 */
bool CheckCollisionForMoving(UserAction_t action, GameInfo_t game_info);

/**
 * @brief Проверяет врежется ли фигура при перемещение влево.
 * @param game_info Информация об игре содержащую поле на котором ищется фигура
 * и смотрится дальше по направлению есть ли дальше другая фигура или край поля.
 * @param collision Флаг который указывает врежется(true) или нет(false)
 */
void CheckCollisionForMovingLeft(GameInfo_t game_info, bool *collision);

/**
 * @brief Проверяет врежется ли фигура при перемещение вправо.
 * @param game_info Информация об игре содержащую поле на котором ищется фигура
 * и смотрится дальше по направлению есть ли дальше другая фигура или край поля.
 * @param collision Флаг который указывает врежется(true) или нет(false)
 */
void CheckCollisionForMovingRight(GameInfo_t game_info, bool *collision);

/**
 * @brief Проверяет врежется ли фигура при перемещение вниз.
 * @param game_info Информация об игре содержащую поле на котором ищется фигура
 * и смотрится дальше по направлению есть ли дальше другая фигура или край поля.
 * @param collision Флаг который указывает врежется(true) или нет(false)
 */
void CheckCollisionForMovingDown(GameInfo_t game_info, bool *collision);

/**
 * @brief Получает информацию о фигуре на игровом поле.
 *
 * @param game_info Структура GameInfo_t, содержащая информацию об игре.
 * @param type Тип фигуры или управление движением:
 * - Положительные значения указывают на тип новой фигуры.
 * - Ноль может использоваться для других целей.
 * - Отрицательные значения управляют движением (например, -1
 *   для поворота, -2 для проверки столкновения).
 *
 * Эта функция управляет состоянием фигуры в игре, обновляя ее тип и
 * положение в зависимости от переданного параметра type. Если type
 * больше нуля, она устанавливает текущую фигуру в зависимости от
 * next_type_figure. Если type равен или меньше нуля,
 * функция проверяет возможность движения фигуры и обновляет ее
 * координаты на игровом поле.
 *
 * @return Указатель на структуру FigureInfo, содержащую информацию
 *         о текущей и следующей фигуре, а также ее состоянии.
 *
 * @note Функция использует статическую переменную для хранения информации
 *       о фигуре, что означает, что состояние будет сохраняться между
 *       вызовами функции.
 */
FigureInfo *GetFigureInfo(GameInfo_t game_info, int type);

/**
 * @brief Получает координаты фигуры.
 * @param game_info Структура содержащая информацию о поле, на котором и
 * находится фигура.
 * @param figure_info Структура содержащая информацию о фигуре, включая тип и
 * положение.
 *
 * Ищет по полю пока не найдет достаточное количество блоков фигуры. Количество
 * зависит от типа фигуры и в каком она находится положении.
 */
void GetCoorFigure(GameInfo_t game_info, FigureInfo *figure_info);

/**
 * @brief Проверяет мешает ли край поля поворачивать фигуру или нет.
 * @param figure_info Структура содержащая информацию о фигуре.
 * @return Возращает edge = true если край поля иначе false.
 */
bool CheckEdgeForRotate(FigureInfo figure_info);

/**
 * @brief Проверяет мешают ли другие фигуры поворачивать текущую фигуру или нет.
 * @param figure_info Структура содержащая информацию о фигуре.
 * @param game_info Структура содержащая информацию о поле включая другие
 * фигуры.
 * @return Возращает collision = true если другие фигуры мешают иначе false.
 */
bool CheckCollisionForRotate(FigureInfo figure_info, GameInfo_t game_info);

/**
 * @brief Поворачивает фигуру на поле.
 * @param figure_info Структура содержащая информацию о фигуре.
 * @param game_info Структура содержащая информацию об игре включая поле.
 */
void RotateTetramino(FigureInfo *figure_info, GameInfo_t *game_info);

/**
 * @brief Поворачивает фигуру I на поле.
 * @param figure_info Структура содержащая информацию о фигуре.
 * @param game_info Структура содержащая информацию об игре включая поле.
 */
void RotateFigureI(FigureInfo *figure_info, GameInfo_t *game_info);

/**
 * @brief Поворачивает фигуру Г, L или T на поле.
 * @param figure_info Структура содержащая информацию о фигуре.
 * @param game_info Структура содержащая информацию об игре включая поле.
 */
void RotateFigureGLT(FigureInfo *figure_info, GameInfo_t *game_info);

/**
 * @brief Поворачивает фигуру S или Z на поле.
 * @param figure_info Структура содержащая информацию о фигуре.
 * @param game_info Структура содержащая информацию об игре включая поле.
 */
void RotateFigureSZ(FigureInfo *figure_info, GameInfo_t *game_info);

/**
 * @brief Реализует конечный автомат и переход из одного состояния игры в
 * другое.
 * @param game_info Структура содержащая информацию об игре.
 * @return Возращает текущее состояние игры.
 */
FieldState FsmField(GameInfo_t *game_info);

/**
 * @brief Реализует состояние игры StartGame.
 * @param game_info Структура содержащая информацию об игре.
 *
 * Считывает сохраненный рекорд, генерирует случайную фигуру которая будет
 * первой появляться, устанавливает счет в 0, а уровень в 1.
 *
 * @return Возвращает следующее состояние игры Spawn.
 */
FieldState FsmStartGame(GameInfo_t *game_info);

/**
 * @brief Записывает в матрицу next следующую фигуру.
 * @param game_info Структура содержащая информацию об игре.
 * @param tetromino Индекс фигуры которую следует записать.
 */
void NextTetromino(GameInfo_t *game_info, int tetromino);

/**
 * @brief Реализует состояние игры Spawn.
 * @param game_info Структура содержащая информацию об игре.
 *
 * Прорисовывает на поле фигуру если может и генерирует следующую которую
 * записывает в next.
 *
 * @return Возвращает следующее состояние игры Shift при возможности нарисовать
 * новую фигуру и GameOver в противном случае.
 */
FieldState FsmSpawn(GameInfo_t *game_info);

/**
 * @brief Проверяет можно ли нарисовать новую фигуру на поле или там есть
 * преграда.
 * @param game_info Структура содержащая информацию об игре
 * @param real_spawn Для фигур содержащих в своей матрице пустую первую строку,
 * нужно смещать их отрисовку на один пиксель выше.
 * @return Возвращает количество блоков которые нельзя отрисовать, если хотя бы
 * один есть фигуру нельзя отрисовать.
 */
int CheckSpawnPossibility(GameInfo_t game_info, int *real_spawn);

/**
 * @brief Реализует состояние игры Shfit.
 * @param game_info Структура содержащая информацию об игре.
 * @param figure_info Структура содержащая информацию об фигуре.
 * @return Возвращает следующее состояние игры - Shift если фигура сдвинулась
 * вниз и Attaching если не может сдвинуться.
 */
FieldState FsmShift(GameInfo_t *game_info, FigureInfo *figure_info);

/**
 * @brief Реализует состояние игры Attaching.
 * @param game_info Структура содержащая информацию об игре.
 *
 * Проверяет снизу вверх есть ли на поле полные линии, есть ли есть стирает их
 * сдвигая все остальное поле вниз. При этом считает количество сотренных линий
 * и в зависимости от этого увеличивает счет.
 *
 * @return Возвращает следующее состояние игры Spawn.
 */
FieldState FsmAttaching(GameInfo_t *game_info);

/**
 * @brief Стирает линию и сдвигает все остальное поле вниз.
 * @param game_info Структура содержащая информацию об игре.
 * @param i Координата строки которую нужно стереть.
 */
void ErasingLine(GameInfo_t *game_info, int i);

/**
 * @brief Реализует состояние игры GameOver.
 * @param game_info Структура содержащая информацию об игре.
 *
 * Проверяет нужно ли переписывать рекорд, при необходимости делает это,
 * устанавливает скорость в значение -1, что является флагом для других функций.
 *
 * @return Возвращает следующее состояние игры Start.
 */
FieldState FsmGameOver(GameInfo_t *game_info);
#ifdef __cplusplus
}
#endif

#endif  // BRICKGAME_V2_0_BRICK_GAME_TETRIS_TETRIS_H